#!/bin/bash
#
# Stack based, low-typing, directory management. Sorta like pushd/popd, but
# different.
#
# ref.
# https://notes.burke.libbey.me/ansi-escape-codes/

#declare -ax _DIR_STACK=()

function _d_init {
   for __ in {1..7} ; do
      printf '\n'
   done
   printf '\e[7F> '
}


function _d_data {
   local -a lines=( "$@" )
   lines=( "${lines[@]::5}" )
   # ^^
   # So cool story: I'm pretty certain that using array slices with "$@" in a
   # function is undocumented, or unintended. E.g., this...
   #> printf '[%s]\n' "${@::5}"
   #...includes the script's $0 as the 1st parameter, followed by any arguments
   # that are passed. So `_d_data 1 2 3` would print `d 1 2 3`. Very confusing.
   #
   # I can not find any references to this behavior, or using "$@" as an array
   # (with slices, parameter expansion, n' whatnot). Seems that substitutions
   # behave as expected, and do not prepend $0.
   #
   # Huh. Given:  foo 'this' 'that' ...
   #
   #  ${@/th/ch}   no prepended $0
   #  ${@#th}      no prepended $0
   #  ${@:0}          prepended $0

   local space
   for (( space=(5 - $#); space>0; space-- )) ; do
      lines+=( '' )
   done

   printf '\e[G\e[K'                    # Prompt
   printf '\e[E\e[K'                    # Padding

   local data
   for data in "${lines[@]}" ; do       # Data
      printf '\e[E\e[K%s' "$data"
   done

   printf '\e[6F> '
}


function d0 {
   while (( $# )) ; do
      case "$1" in
         # DUP top entry on the stack.
         d) shift
            (( ${#_DIR_STACK[@]} )) || return 0
            _DIR_STACK+=( "${_DIR_STACK[-1]}" )
            ;;

         # SWAP top two dirs on the stack.
         s) shift
            (( ${#_DIR_STACK[@]} >= 2 )) || return 1
            _DIR_STACK+=( "${_DIR_STACK[-2]}" )
            unset '_DIR_STACK[-3]'

            _DIR_STACK=( "${_DIR_STACK[@]}" ) # patch holes
            ;;

         # PUSH cwd.
         p) shift
            _DIR_STACK+=( "$PWD" )
            ;;

         # ROT dirs down.
         r) shift
            (( ${#_DIR_STACK[@]} >= 3 )) || return 1
            local a="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            local b="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            local c="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            DIRSTACK+=( "$c" "$a" "$b" )
            ;;

         # TOGGLE between the top two directories:  SWAP DUP .
         t) shift
            set -- s d . "$@"
            ;;

         # LIST directories on the stack.
         l) shift
            (( ${#_DIR_STACK[@]} )) || return 0
            realpath -ms --relative-base="$PWD"  "${_DIR_STACK[@]::5}" \
            | sed "s,${HOME},~," \
            | column -t          \
            | tac
            ;;

         # CYCLE all directories upwards.
         c) shift
            (( ${#_DIR_STACK[@]} )) || return 0
            _DIR_STACK=( "${_DIR_STACK[-1]}"  "${_DIR_STACK[@]::${#_DIR_STACK[@]}-1}" )
            ;;

         # Pops top of stack, `cd`
         '.')  shift
            (( ${#_DIR_STACK[@]} )) || return 1
            cd "${_DIR_STACK[-1]}" || return 1
            unset '_DIR_STACK[-1]'
            ;;

         ??*) 
            set -- "${1::1}" "${1:1}" "${@:2}"
            ;;
      esac
   done
}


function d {
   _d_init

   trap '_d_data ; printf "\n" ; return' SIGINT

   local c
   while IFS= read -srn1 c ; do
      printf '%s' "$c"

      local d=
      local -a dirs=()
      for d in "${_DIR_STACK[@]::5}" ; do
         d=$( realpath -ms --relative-base="$PWD"  "$d" )
         dirs=( "$d" "${dirs[@]}" )
      done

      _d_data "${dirs[@]/${HOME}/'~'}"

      case "$c" in
         # DUP top entry on the stack.
         d) shift
            (( ${#_DIR_STACK[@]} )) || return 0
            _DIR_STACK+=( "${_DIR_STACK[-1]}" )
            ;;

         # SWAP top two dirs on the stack.
         s) shift
            (( ${#_DIR_STACK[@]} >= 2 )) || return 1
            _DIR_STACK+=( "${_DIR_STACK[-2]}" )
            unset '_DIR_STACK[-3]'

            _DIR_STACK=( "${_DIR_STACK[@]}" ) # patch holes
            ;;

         # PUSH cwd.
         p) shift
            _DIR_STACK+=( "$PWD" )
            ;;

         # ROT dirs down.
         r) shift
            (( ${#_DIR_STACK[@]} >= 3 )) || return 1
            local a="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            local b="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            local c="${DIRSTACK[-1]}" ; unset 'DIRSTACK[-1]'
            DIRSTACK+=( "$c" "$a" "$b" )
            ;;

         # TOGGLE between the top two directories:  SWAP DUP .
         t) shift
            set -- s d . "$@"
            ;;

         # CYCLE all directories upwards.
         c) shift
            (( ${#_DIR_STACK[@]} )) || return 0
            _DIR_STACK=( "${_DIR_STACK[-1]}"  "${_DIR_STACK[@]::${#_DIR_STACK[@]}-1}" )
            ;;

         # Pops top of stack, `cd`
         '.')  shift
            (( ${#_DIR_STACK[@]} )) || return 1
            cd "${_DIR_STACK[-1]}" || return 1
            unset '_DIR_STACK[-1]'
            ;;

         ??*) 
            set -- "${1::1}" "${1:1}" "${@:2}"
            ;;

         '' | ';')
            _d_data
            printf '\nBYE.\n' ; break ;;

         '	') :;; # Ignore tabs.
      esac
   done
}


_DIR_STACK=( ~/.config/i3 "$PWD" ~/hg/twce/awkdoc )
